import{fR as R,bk as j,fS as w,eG as E}from"./index-BK4NQ6A4.js";function G(n,e,r,o){if(n.type==="point")return n.x+=e,n.y+=r,n.hasZ&&o!=null,n;if(n.type==="multipoint"){const x=n.points;for(let a=0;a<x.length;a++)x[a]=z(x[a],e,r,o);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=r,n.ymax+=r,n;const m=R(n),t=n.type==="polyline"?n.paths:n.rings;for(let x=0;x<m.length;x++){const a=m[x];for(let s=0;s<a.length;s++)a[s]=z(a[s],e,r,o)}return"paths"in n?n.paths=t:n.rings=t,n}function H(n,e,r,o,m){const t=n.clone(),x=o.resolution;if(t.type==="point"){if(m)G(t,e*x,-r*x);else{const a=o.state.transform,s=o.state.inverseTransform,l=a[0]*t.x+a[2]*t.y+a[4],f=a[1]*t.x+a[3]*t.y+a[5];t.x=s[0]*(l+e)+s[2]*(f+r)+s[4],t.y=s[1]*(l+e)+s[3]*(f+r)+s[5]}return t}if(t.type==="multipoint"){if(m)G(t,e*x,-r*x);else{const a=t.points,s=o.state.transform,l=o.state.inverseTransform;for(let f=0;f<a.length;f++){const c=a[f],p=s[0]*c[0]+s[2]*c[1]+s[4],v=s[1]*c[0]+s[3]*c[1]+s[5],y=l[0]*(p+e)+l[2]*(v+r)+l[4],u=l[1]*(p+e)+l[3]*(v+r)+l[5];a[f]=d(c,y,u)}}return t}if(t.type==="extent"){if(m)G(t,e*x,-r*x);else{const a=o.state.transform,s=o.state.inverseTransform,l=a[0]*t.xmin+a[2]*t.ymin+a[4],f=a[1]*t.xmin+a[3]*t.ymin+a[5],c=a[0]*t.xmax+a[2]*t.ymax+a[4],p=a[1]*t.xmax+a[3]*t.ymax+a[5];t.xmin=s[0]*(l+e)+s[2]*(f+r)+s[4],t.ymin=s[1]*(l+e)+s[3]*(f+r)+s[5],t.xmax=s[0]*(c+e)+s[2]*(p+r)+s[4],t.ymax=s[1]*(c+e)+s[3]*(p+r)+s[5]}return t}if(m)G(t,e*x,-r*x);else{const a=R(t),s=t.type==="polyline"?t.paths:t.rings,l=o.state.transform,f=o.state.inverseTransform;for(let c=0;c<a.length;c++){const p=a[c];for(let v=0;v<p.length;v++){const y=p[v],u=l[0]*y[0]+l[2]*y[1]+l[4],h=l[1]*y[0]+l[3]*y[1]+l[5],M=f[0]*(u+e)+f[2]*(h+r)+f[4],g=f[1]*(u+e)+f[3]*(h+r)+f[5];p[v]=d(y,M,g)}}"paths"in t?t.paths=s:t.rings=s}return t}function I(n,e,r,o){if(n.type==="point"){const{x:y,y:u}=n,h=o?o[0]:y,M=o?o[1]:u,g=n.clone(),T=(y-h)*e+h,i=(u-M)*r+M;return g.x=T,g.y=i,g}if(n.type==="multipoint"){const y=R(n),u=j(),[h,M,g,T]=w(u,[y]),i=o?o[0]:(h+g)/2,q=o?o[1]:(T+M)/2,b=n.clone(),S=b.points;for(let k=0;k<S.length;k++){const Z=S[k],[A,B]=Z,C=(A-i)*e+i,D=(B-q)*r+q;S[k]=d(Z,C,D)}return b}if(n.type==="extent"){const{xmin:y,xmax:u,ymin:h,ymax:M}=n,g=o?o[0]:(y+u)/2,T=o?o[1]:(M+h)/2,i=n.clone();if(i.xmin=(y-g)*e+g,i.ymax=(M-T)*r+T,i.xmax=(u-g)*e+g,i.ymin=(h-T)*r+T,i.xmin>i.xmax){const q=i.xmin,b=i.xmax;i.xmin=b,i.xmax=q}if(i.ymin>i.ymax){const q=i.ymin,b=i.ymax;i.ymin=b,i.ymax=q}return i}const m=R(n),t=j(),[x,a,s,l]=w(t,m),f=o?o[0]:(x+s)/2,c=o?o[1]:(l+a)/2,p=n.clone(),v=p.type==="polyline"?p.paths:p.rings;for(let y=0;y<m.length;y++){const u=m[y];for(let h=0;h<u.length;h++){const M=u[h],[g,T]=M,i=(g-f)*e+f,q=(T-c)*r+c;v[y][h]=d(M,i,q)}}return"paths"in p?p.paths=v:p.rings=v,p}function J(n,e,r,o,m,t){const x=Math.sqrt((r-n)*(r-n)+(o-e)*(o-e));return Math.sqrt((m-n)*(m-n)+(t-e)*(t-e))/x}function K(n,e,r,o=!1){const m=Math.atan2(e.y-r.y,e.x-r.x)-Math.atan2(n.y-r.y,n.x-r.x),t=Math.atan2(Math.sin(m),Math.cos(m));return o?t:E(t)}function z(n,e,r,o){return d(n,n[0]+e,n[1]+r,n[2]!=null&&o!=null?n[2]+o:void 0)}function d(n,e,r,o){const m=[e,r];return n.length>2&&m.push(n[2]),n.length>3&&m.push(n[3]),m}export{J as a,H as i,K as m,I as s};
